# Техническое задание (ТЗ)

## 1. Общее описание
Необходимо разработать REST API для управления списком книг.
Приложение должно уметь добавлять книги, показывать список, искать конкретную книгу, обновлять данные и удалять книги.
Данные должны храниться в базе данных SQLite (файл library.db).

## 2. Структура проекта
Обязательная структура папок:

```
my_library/
├── main.py              # Запуск приложения, подключение роутеров
├── database.py          # Настройка движка (Engine) и сессий
├── models/              # SQLAlchemy модели (Таблицы)
│   └── books.py
├── schemas/             # Pydantic схемы (Валидация)
│   └── books.py
├── routers/             # Эндпоинты (HTTP логика)
│   └── books.py
└── repository.py        # Логика работы с БД (SQL-запросы)
```
## 3. Модель данных (База данных)
В файле models/books.py создайте таблицу books со следующими колонками:

|Поле   |Тип SQL|Тип Python|Описание                                |
|-------|-------|----------|----------------------------------------|
|id     |INTEGER|int       |Первичный ключ (Primary Key)            |
|title  |VARCHAR|str       |Название книги (не может быть пустым)   |
|author |VARCHAR|str       |Автор книги (не может быть пустым)      |
|year   |INTEGER|int       |Год издания                             |
|pages  |INTEGER|int       |Количество страниц                      |
|is_read|BOOLEAN|bool      |Прочитана ли книга (по умолчанию False) |

## 4. Схемы данных (Pydantic)
В файле schemas/books.py реализуйте схемы:
#### A. SBookAdd (для создания/обновления):
-  Поля: title, author, year, pages, is_read.
- Все поля обязательны (кроме is_read — по умолчанию False).
- Валидация: pages должно быть больше 10.
#### B. SBook (для возврата клиенту):
- Включает в себя все поля из SBookAdd плюс поле id.
- Включить from_attributes = True.

## 5. API Эндпоинты
Реализуйте роутер /books со следующими методами.
Все методы должны использовать Dependency Injection для получения сессии БД и Repository для выполнения SQL-запросов.
#### A. Добавить книгу
- Метод: POST /books
- Вход: JSON (схема SBookAdd).
- Выход: Созданная книга (схема SBook).
- Статус: 201 Created.
#### B. Получить все книги
- Метод: GET /books
- Выход: Список книг (list[SBook]).
- Статус: 200 OK.
#### C. Получить одну книгу
- Метод: GET /books/{id}
- Вход: ID книги (int).
- Выход: Объект книги (SBook).
- Логика: Если книги с таким ID нет — вернуть ошибку 404 Not Found с текстом "Книга не найдена".
#### D. Обновить книгу
- Метод: PUT /books/{id} (полное обновление)
- Вход: ID книги и JSON (схема SBookAdd).
- Выход: Обновленная книга (SBook).
- Логика: Если книги нет — ошибка 404.
#### E. Удалить книгу
- Метод: DELETE /books/{id}
- Вход: ID книги.
- Выход: Пустота.
- Статус: 204 No Content.
- Логика: Если книги нет — ошибка 404.

## 6. Требования к коду
- Repository Pattern: В роутере (routers/books.py) не должно быть импортов select, insert, delete из SQLAlchemy.
  Вся работа с базой должна быть вынесена в класс BookRepository в файле repository.py.
- Асинхронность: Используйте async/await везде (в роутерах и в репозитории).
- Константы: Используйте status.HTTP_... вместо чисел.

## 7. Советы по выполнению
- Начните с файла database.py и настройки подключения.
- Опишите модель BooksModel и проверьте, что файл library.db создается при запуске (настройте lifespan в main.py).
- Напишите схемы Pydantic.
- Создайте репозиторий и реализуйте метод add_book.
- Создайте роутер и подключите его к main.py.
- Протестируйте создание книги через Swagger UI.
- Реализуйте остальные методы по очереди.

